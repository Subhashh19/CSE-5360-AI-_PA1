(princ " 8 puzzle format ((E a b) (c d e) (f g h)) ~" )
(terpri)
(princ "Example -  ((E 1 3) (4 2 5) (7 8 6)) " )
(terpri)
(princ "Where E is the EMPTY TILE " )
(terpri)
(defvar priorPuzzle (read)) 
(defvar eState 0) 
(defvar ct_misp 0) 
(defvar exg_record '()) 
(defvar exg_state '()) 
(defvar h_least '()) 
(defvar terminate_record '()) 
(defvar open_record '()) 
(defvar trecord '()) 
(defvar counter 0) 


(defun find_state() 
  (if(eq 'E (car(car priorPuzzle)))
    (setq eState 0)
  )
  (if(eq 'E (cadr(car priorPuzzle)))
    (setq eState 1)
  )
  (if(eq 'E (caddr(car priorPuzzle)))
    (setq eState 2)
  )
  (if(eq 'E (car(cadr priorPuzzle)))
    (setq eState 3)
  )
  (if(eq 'E (cadr(cadr priorPuzzle)))
    (setq eState 4)
  )
  (if(eq 'E (caddr(cadr priorPuzzle)))
    (setq eState 5)
  )
  (if(eq 'E (car(caddr priorPuzzle)))
    (setq eState 6)
  )
  (if(eq 'E (cadr(caddr priorPuzzle)))
    (setq eState 7)
  )
  (if(eq 'E (caddr(caddr priorPuzzle)))
    (setq eState 8)
  )
)

(defun find_state1(priorPuzzle)
  (if(eq 'E (nth 0 priorPuzzle))
    (setq eState 0)
  )
  (if(eq 'E (nth 1 priorPuzzle))
    (setq eState 1)
  )
  (if(eq 'E (nth 2 priorPuzzle))
    (setq eState 2)
  )
  (if(eq 'E (nth 3 priorPuzzle))
    (setq eState 3)
  )
  (if(eq 'E (nth 4 priorPuzzle))
    (setq eState 4)
  )
  (if(eq 'E (nth 5 priorPuzzle))
    (setq eState 5)
  )
  (if(eq 'E (nth 6 priorPuzzle))
    (setq eState 6)
  )
  (if(eq 'E (nth 7 priorPuzzle))
    (setq eState 7)
  )
  (if(eq 'E (nth 8 priorPuzzle))
    (setq eState 8)
  )
)


(defun lost_tile()
  (setf ct_misp 0)
  (if(not(eq 1 (car(car priorPuzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 2 (cadr(car priorPuzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 3 (caddr(car priorPuzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 4 (car(cadr priorPuzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 5 (cadr(cadr priorPuzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 6 (caddr(cadr priorPuzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 7 (car(caddr priorPuzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 8 (cadr(caddr priorPuzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
)


(defun lost_tile1(Puzzle)
  (setf ct_misp 0)
  (if(not(eq 1 (car Puzzle)))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 2 (cadr Puzzle)))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 3 (caddr Puzzle)))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 4 (cadddr Puzzle)))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 5 (car(nthcdr 4 Puzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 6 (car(nthcdr 5 Puzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 7 (car(nthcdr 6 Puzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
  (if(not(eq 8 (car(nthcdr 7 Puzzle))))
    (setq ct_misp (+ ct_misp 1))
  )
)

(defun generate-position(puzzle pos)
  (setf exg_record '())
  (if(= eState 0)
    (push '(1 3) exg_record)
  )
  (if(= eState 1)
    (push '(0 2 4) exg_record)
  )
  (if(= eState 2)
    (push '(1 5) exg_record)
  )
  (if(= eState 3)
    (push '(0 4 6) exg_record)
  )
  (if(= eState 4)
    (push '(1 3 5 7) exg_record)
  )
  (if(= eState 5)
    (push '(2 4 8) exg_record)
  )
  (if(= eState 6)
    (push '(3 7) exg_record)
  )
  (if(= eState 7)
    (push '(6 8 4) exg_record)
  )
  (if(= eState 8)
    (push '(5 7) exg_record)
  )
)


(defun exg_fun (list position state_exchange)
  (loop for statep_exg in state_exchange
        for rotate_list = (copy-list list)
        do (rotatef (nth position rotate_list)
                    (nth statep_exg rotate_list))
        collect rotate_list))

(defun sRecord(trecord) 
  (setf counter (+ counter 1)) 
    (lost_tile1 (car trecord))
    (defparameter la1 ct_misp)
    (defparameter lb1 (+(- (car (last (car trecord) 2)) (car (last (car trecord) 1)))1))
    (defparameter lc1 (+ lb1 la1))
    (defparameter listbuild1 (car trecord))
    (setf (nth 9 listbuild1) lc1)
    (setf (nth 10 listbuild1) la1)
    (format t " ~a ~%" listbuild1)
    (defparameter lb1 (subseq listbuild1 0 9))
    (defparameter vala1 (position lb1 terminate_record :test #'equal))
    (if(eq vala1 Nil)
      (push listBuild1 open_record)
    )



    (lost_tile1 (cadr trecord))
    (defparameter la2 ct_misp)
    (defparameter lb2 (+(- (car (last (cadr trecord) 2)) (car (last (cadr trecord) 1)))1))
    (defparameter lc2 (+ la2 lb2))
    (defparameter listbuild2 (cadr trecord))
    (setf (nth 9 listbuild2) lc2)
    (setf (nth 10 listbuild2) la2)
    (format t " ~a ~%" listbuild2)
    (defparameter lb1 (subseq listbuild2 0 9))
    (defparameter val2 (position lb1 terminate_record
          :test #'equal))
    (if(eq val2 Nil)
      (push listbuild2 open_record)
    )


  (if (not(eq (caddr trecord) Nil))
    (progn
      (lost_tile1 (caddr trecord))
      (defparameter la3 ct_misp)
      (defparameter lb3 (+(- (car (last (caddr trecord) 2)) (car (last (caddr trecord) 1)))1))
      (defparameter lc3 (+ lb3 la3))
      (defparameter listbuild3 (caddr trecord))
      (setf (nth 9 listbuild3) lc3)
      (setf (nth 10 listbuild3) la3)
      (format t " ~a ~%" listbuild3)
      (defparameter lb3 (subseq listBuild3 0 9))
      (defparameter val3 (position lb3 terminate_record :test #'equal))
      (if(eq val3 Nil)
        (push listbuild3 open_record)
      )   
    )
  )

  (if (not(eq (cadddr trecord) Nil))
    (progn
      (lost_tile1 (cadddr trecord))
      (defparameter la4 ct_misp)
      (defparameter lb4 (+(- (car (last (cadddr trecord) 2)) (car (last (cadddr trecord) 1)))1))
      (defparameter lc4 (+ lb4 la4))
      (defparameter listbuild4 (cadddr trecord))
      (setf (nth 9 listbuild4) lc4)
      (setf (nth 10 listbuild4) la4)
      (format t " ~a ~%" listbuild4)
      (defparameter lb4 (subseq listbuild4 0 9))
      (defparameter val4 (position lb4 terminate_record
            :test #'equal))
      (if(eq val4 Nil)
        (push listbuild4 open_record)
      )
    )
  )
  (sort open_record #'<= :key #'tenth)
  (defparameter  nChild (car open_record)) 
  (defparameter fchild (nth 9 nChild))
  (defparameter sort_record '())
  (loop for x in open_record
    do (progn
        (defparameter nthval (nth 9 x))
        (if (= nthval fchild)
          (push x sort_record)
        )
      )
  )
  (defun eleventh (sort_record) (nth 10 sort_record))
  (sort sort_record #'<= :key #'eleventh)
  (setf nChild (car sort_record))
  (format t "New Child ~a ~%" nChild) 
  (setq open_record (delete nChild open_record))
  (push (subseq nChild 0 9) terminate_record)
  (defparameter minimumab (nth 10 nChild))
  
  (if(= minab 0)
    (progn 
     
      (exit)
    )
   (progn
      
    (find_state 1 nChild)
     (build_st nChild eState)
    )
  )

)

(defun build_st(puzzle pos)
  (generate-position puzzle pos)
  (setf trecord '())
  (setf trecord (exg_fun puzzle pos (car exg_record))) 
  (sRecord trecord)
)


(find_state ) 
(lost_tile) 
(defvar mg_record (append (car priorPuzzle) (append (cadr priorPuzzle) (caddr priorPuzzle))))

(defvar traverse 0)
(defvar yloop (cdr mg_record))

(loop for x in mg_record
  do (
      loop for y in yloop
      do (if(and(and (not(eq x 'E)) (not(eq y 'E)))(> x y))         
          (progn
        
            (setf traverse (+ traverse 1))  
            )
         )
    )
    (setf yloop (cdr yloop))
    
)
(if(eq (mod traverse 2) 1)
  (progn
    (format t "~%INFEASIBLE PUZZLE~%")
    (format t "Total traverse = ~a~%" traverse)
    (exit)
  )
)

(push mg_record terminate_record) 
(setq mg_record (append mg_record (list ct_misp))) 
(setq mg_record (append mg_record (list ct_misp))) 
(lost_tile1 mg_record)


(if(= ct_misp 0)
  (progn
    (print "The Puzzled is in Solved State")
    (exit)
  )
)

(build_st mg_record eState)